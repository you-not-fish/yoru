/*
 * Yoru Runtime - ABI Definitions
 *
 * This header defines the interface between the Yoru compiler and runtime.
 * All structures and functions defined here form a stable ABI contract.
 */

#ifndef YORU_RUNTIME_H
#define YORU_RUNTIME_H

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * =============================================================================
 * Type Descriptor
 * =============================================================================
 *
 * Each type has a static TypeDesc that describes its layout for GC.
 * Generated by the compiler as global constants.
 */

typedef struct TypeDesc {
    size_t size;             /* size in bytes (excluding header) */
    size_t num_ptrs;         /* number of GC-managed ref fields */
    const uint32_t* offsets; /* offsets of ref fields (relative to data start) */
} TypeDesc;

/*
 * =============================================================================
 * Object Header
 * =============================================================================
 *
 * Every heap-allocated object has a 16-byte header:
 *
 *   +------------------+------------------+
 *   |   TypeDesc* (8)  |   next_mark (8)  |
 *   +------------------+------------------+
 *   |              data...                |
 *   +-------------------------------------+
 *
 * next_mark layout:
 *   - bits [63:1] = next pointer (aligned, so bit 0 is always 0)
 *   - bit 0 = GC mark bit
 */

typedef struct ObjHeader {
    const TypeDesc* type;    /* pointer to type descriptor */
    uintptr_t next_mark;     /* next object in alloc list + mark bit */
} ObjHeader;

/* Object structure: header followed by data */
typedef struct Object {
    ObjHeader header;
    char data[];             /* flexible array member */
} Object;

/* Macros for next_mark manipulation */
#define OBJ_NEXT(obj)       ((Object*)((obj)->header.next_mark & ~(uintptr_t)1))
#define OBJ_MARKED(obj)     ((obj)->header.next_mark & 1)
#define OBJ_SET_NEXT(obj, n) ((obj)->header.next_mark = \
    ((uintptr_t)(n) & ~(uintptr_t)1) | OBJ_MARKED(obj))
#define OBJ_SET_MARK(obj)   ((obj)->header.next_mark |= 1)
#define OBJ_CLEAR_MARK(obj) ((obj)->header.next_mark &= ~(uintptr_t)1)

/* Get data pointer from object */
#define OBJ_DATA(obj)       ((void*)((obj)->data))

/* Get object from data pointer */
#define DATA_TO_OBJ(ptr)    ((Object*)((char*)(ptr) - offsetof(Object, data)))

/*
 * =============================================================================
 * String Type
 * =============================================================================
 *
 * Yoru strings are immutable and represented as (ptr, len) pairs.
 * The string data is NOT null-terminated (length is explicit).
 */

typedef struct YoruString {
    const char* ptr;         /* pointer to string data */
    int64_t len;             /* length in bytes */
} YoruString;

/*
 * =============================================================================
 * Interface Type
 * =============================================================================
 *
 * Interfaces are fat pointers: (type_info, data_ptr)
 */

typedef struct YoruInterface {
    const void* itable;      /* interface method table */
    void* data;              /* pointer to concrete value */
} YoruInterface;

/*
 * =============================================================================
 * Runtime Functions - Memory Allocation
 * =============================================================================
 */

/*
 * Allocate a new object of the given type.
 * May trigger GC if memory pressure is high.
 *
 * @param size  Object size (must match type->size)
 * @param type  Type descriptor for the object
 * @return      Pointer to the data area (NOT the header)
 */
void* rt_alloc(uint64_t size, const TypeDesc* type);

/*
 * =============================================================================
 * Runtime Functions - Garbage Collection
 * =============================================================================
 */

/*
 * Trigger a garbage collection cycle.
 * This is a stop-the-world mark-sweep collection.
 */
void rt_collect(void);

/*
 * Initialize the runtime system.
 * Must be called before any other runtime function.
 */
void rt_init(void);

/*
 * Shutdown the runtime system.
 * Frees all allocated memory.
 */
void rt_shutdown(void);

/*
 * =============================================================================
 * Runtime Functions - Error Handling
 * =============================================================================
 */

/*
 * Trigger a panic with the given message.
 * Prints stack trace and terminates the program.
 *
 * @param msg  Panic message (null-terminated C string)
 */
void rt_panic(const char* msg) __attribute__((noreturn));

/*
 * Panic with a Yoru string message.
 *
 * @param msg  Panic message as Yoru string
 */
void rt_panic_string(YoruString msg) __attribute__((noreturn));

/*
 * =============================================================================
 * Runtime Functions - I/O
 * =============================================================================
 */

/*
 * Print an integer to stdout.
 */
void rt_print_i64(int64_t x);

/*
 * Print a float to stdout.
 */
void rt_print_f64(double x);

/*
 * Print a boolean to stdout.
 */
void rt_print_bool(int8_t b);

/*
 * Print a string to stdout.
 */
void rt_print_string(YoruString s);

/*
 * Print a newline to stdout.
 */
void rt_println(void);

/*
 * =============================================================================
 * Runtime Functions - Bounds Checking
 * =============================================================================
 */

/*
 * Check array bounds and panic if out of range.
 *
 * @param index  The index being accessed
 * @param len    The length of the array
 */
void rt_bounds_check(int64_t index, int64_t len);

/*
 * =============================================================================
 * Runtime Statistics (for debugging)
 * =============================================================================
 */

typedef struct RuntimeStats {
    uint64_t alloc_count;    /* total allocations */
    uint64_t gc_count;       /* number of GC cycles */
    uint64_t live_objects;   /* objects currently alive */
    uint64_t heap_size;      /* total heap size in bytes */
    uint64_t freed_count;    /* objects freed by GC */
} RuntimeStats;

/*
 * Get current runtime statistics.
 */
RuntimeStats rt_get_stats(void);

/*
 * Print runtime statistics to stderr.
 */
void rt_print_stats(void);

/*
 * =============================================================================
 * LLVM GC Integration
 * =============================================================================
 *
 * The compiler uses LLVM's shadow-stack GC strategy.
 * LLVM maintains a linked list of stack frames at:
 *   extern struct StackEntry* llvm_gc_root_chain;
 *
 * Each stack frame contains pointers to GC roots on the stack.
 * The runtime traverses this chain during garbage collection.
 */

/* LLVM shadow-stack frame map (generated by LLVM) */
struct FrameMap {
    int32_t num_roots;       /* number of roots in frame */
    int32_t num_meta;        /* number of metadata entries */
    const void* meta[];      /* metadata for each root */
};

/* LLVM shadow-stack entry (maintained by LLVM) */
struct StackEntry {
    struct StackEntry* next; /* link to caller's frame */
    const struct FrameMap* map;  /* static frame descriptor */
    void* roots[];           /* addresses of root slots (void**) */
};

/* Global GC root chain (defined by LLVM runtime) */
extern struct StackEntry* llvm_gc_root_chain;

/*
 * =============================================================================
 * Built-in Type Descriptors
 * =============================================================================
 *
 * These are predefined type descriptors for primitive types.
 * The compiler can reference these directly.
 */

extern const TypeDesc rt_type_int;
extern const TypeDesc rt_type_float;
extern const TypeDesc rt_type_bool;
extern const TypeDesc rt_type_string;

#ifdef __cplusplus
}
#endif

#endif /* YORU_RUNTIME_H */
