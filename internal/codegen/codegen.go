// Package codegen generates textual LLVM IR from SSA functions.
//
// The generated IR uses opaque pointers (ptr) per LLVM 15+.
// Boolean values are i1 in SSA flow, with zext/trunc at runtime function boundaries.
package codegen

import (
	"fmt"
	"io"

	"github.com/you-not-fish/yoru/internal/rtabi"
	"github.com/you-not-fish/yoru/internal/ssa"
	"github.com/you-not-fish/yoru/internal/types"
)

// generator holds the state for generating LLVM IR for a module.
type generator struct {
	e     emitter
	sizes *types.Sizes

	// String constant table: maps string content to index.
	strings   []string
	stringMap map[string]int
}

// Generate writes LLVM IR for the given SSA functions to w.
func Generate(w io.Writer, funcs []*ssa.Func, sizes *types.Sizes) error {
	g := &generator{
		e:         emitter{w: w},
		sizes:     sizes,
		stringMap: make(map[string]int),
	}

	// Pre-scan: collect all string constants from all functions.
	g.collectStrings(funcs)

	// Module header.
	g.emitHeader()

	// String globals.
	if len(g.strings) > 0 {
		g.e.emitComment("String constants")
		for i, s := range g.strings {
			g.emitStringGlobal(i, s)
		}
		g.e.emitLine()
	}

	// Runtime function declarations.
	g.emitRuntimeDecls()

	// Intrinsic declarations.
	g.emitIntrinsicDecls(funcs)

	// User functions.
	g.e.emitComment("User functions")
	for i, fn := range funcs {
		if i > 0 {
			g.e.emitLine()
		}
		g.lowerFunc(fn)
	}

	g.e.emitLine()

	return g.e.err
}

// emitHeader writes the module header (target triple, data layout).
func (g *generator) emitHeader() {
	g.e.emitComment("Generated by Yoru compiler")
	g.e.emit("target datalayout = %q", rtabi.DataLayout)
	g.e.emit("target triple = %q", rtabi.TargetTriple)
	g.e.emitLine()
}

// emitStringGlobal writes a string global constant.
func (g *generator) emitStringGlobal(idx int, s string) {
	escaped := llvmEscapeString(s)
	g.e.emit("@.str.%d = private unnamed_addr constant [%d x i8] c\"%s\"", idx, len(s), escaped)
}

// emitRuntimeDecls writes the runtime function declarations.
func (g *generator) emitRuntimeDecls() {
	g.e.emitComment("Runtime function declarations")

	attrIdx := 0
	var attrs []string

	for _, fn := range rtabi.RuntimeFunctions() {
		var paramStr string
		if len(fn.ParamTypes) > 0 {
			paramStr = joinTypes(fn.ParamTypes)
		}

		decl := fmt.Sprintf("declare %s @%s(%s)", fn.ReturnType, fn.Name, paramStr)
		if fn.NoReturn {
			decl += fmt.Sprintf(" #%d", attrIdx)
			attrs = append(attrs, fmt.Sprintf("attributes #%d = { noreturn }", attrIdx))
			attrIdx++
		}
		g.e.emit(decl)
	}

	g.e.emitLine()

	// Emit attribute groups.
	for _, attr := range attrs {
		g.e.emit(attr)
	}
	if len(attrs) > 0 {
		g.e.emitLine()
	}
}

// emitIntrinsicDecls writes LLVM intrinsic declarations if needed.
func (g *generator) emitIntrinsicDecls(funcs []*ssa.Func) {
	needsMemset := false
	for _, fn := range funcs {
		for _, b := range fn.Blocks {
			for _, v := range b.Values {
				if v.Op == ssa.OpZero {
					needsMemset = true
				}
			}
		}
	}

	if needsMemset {
		g.e.emitComment("LLVM intrinsics")
		g.e.emit("declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)")
		g.e.emitLine()
	}
}

// collectStrings pre-scans all functions to collect string constants.
// This ensures all string globals are emitted at the top of the module.
func (g *generator) collectStrings(funcs []*ssa.Func) {
	for _, fn := range funcs {
		for _, b := range fn.Blocks {
			for _, v := range b.Values {
				if v.Op == ssa.OpConstString {
					if s, ok := v.Aux.(string); ok {
						g.stringIndex(s)
					}
				}
				// OpPrintln may need space separator.
				if v.Op == ssa.OpPrintln && len(v.Args) > 1 {
					g.stringIndex(" ")
				}
			}
		}
	}
}

// joinTypes joins type strings with ", ".
func joinTypes(types []string) string {
	if len(types) == 0 {
		return ""
	}
	result := types[0]
	for _, t := range types[1:] {
		result += ", " + t
	}
	return result
}
